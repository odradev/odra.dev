"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[32103],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=s(n),m=r,b=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(b,l(l({ref:t},u),{},{components:n})):a.createElement(b,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},60208:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const o={},l="Attributes",i={unversionedId:"advanced/attributes",id:"version-0.5.0/advanced/attributes",title:"Attributes",description:"Smart contract developers with Ethereum background are familiar with Solidity's concept of modifiers in Solidity - a feature that allows developers to embed common checks into function definitions in a readable and reusable manner. These are essentially prerequisites for function execution.",source:"@site/versioned_docs/version-0.5.0/advanced/04-attributes.md",sourceDirName:"advanced",slug:"/advanced/attributes",permalink:"/docs/0.5.0/advanced/attributes",draft:!1,tags:[],version:"0.5.0",lastUpdatedAt:1691663853,formattedLastUpdatedAt:"Aug 10, 2023",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Advanced Storage Concepts",permalink:"/docs/0.5.0/advanced/advanced-storage"},next:{title:"Signatures",permalink:"/docs/0.5.0/advanced/signatures"}},c={},s=[{value:"Init",id:"init",level:2},{value:"Example",id:"example",level:3},{value:"Using",id:"using",level:2},{value:"Example",id:"example-1",level:3},{value:"Payable",id:"payable",level:2},{value:"Example",id:"example-2",level:3},{value:"Non Reentrant",id:"non-reentrant",level:2},{value:"Mixing attributes",id:"mixing-attributes",level:2}],u={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"attributes"},"Attributes"),(0,r.kt)("p",null,"Smart contract developers with Ethereum background are familiar with Solidity's concept of modifiers in Solidity - a feature that allows developers to embed common checks into function definitions in a readable and reusable manner. These are essentially prerequisites for function execution."),(0,r.kt)("p",null,"Odra defines a few attributes that can be applied to functions to equip them with superpowers."),(0,r.kt)("h2",{id:"init"},"Init"),(0,r.kt)("p",null,"If your contract needs initial setup, adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra(init)]")," attribute to your function operates similarly to a constructor in object-oriented programming. This constructor is called immediately after the contract is deployed."),(0,r.kt)("p",null,"It's important to note that a constructor function should not be invoked in any other context."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=examples/src/contracts/erc20.rs",title:"examples/src/contracts/erc20.rs"},"#[odra(init)]\npub fn init(&mut self, name: String, symbol: String, decimals: u8, initial_supply: &U256) {\n    let caller = contract_env::caller();\n    self.name.set(name);\n    self.symbol.set(symbol);\n    self.decimals.set(decimals);\n    self.mint(&caller, initial_supply);\n}\n")),(0,r.kt)("h2",{id:"using"},"Using"),(0,r.kt)("p",null,"An attribute applicable to struct fields. The ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," attribute accepts multiple values, separated by ",(0,r.kt)("inlineCode",{parentName:"p"},","),".\nEach value attribute must point at an existing field."),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[odra::module]\nstruct Contract {\n  access_control: AccessControl,\n  meta: Metadata,\n  #[odra(using = "access_control, meta")]\n  // #[odra(using = "access_control, metadata")] - would not compile - `metadata` field does not exist\n  storage: Storage\n}\n\n#[odra::module]\nstruct AccessControl {\n  owner: Variable<Address>\n}\n\n#[odra::module]\nstruct Metadata {\n  version: Variable<String>\n}\n\n#[odra::module]\nstruct Storage {\n  value: Variable<u8>,\n  access_control: AccessControl,\n  meta: Metadata\n}\n')),(0,r.kt)("h2",{id:"payable"},"Payable"),(0,r.kt)("p",null,"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra(payable)]")," attribute can send and take money in the form of native tokens. "),(0,r.kt)("h3",{id:"example-2"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=examples/src/contracts/tlw.rs",title:"examples/src/contracts/tlw.rs"},"#[odra(payable)]\npub fn deposit(&mut self) {\n    // Extract values\n    let caller: Address = contract_env::caller();\n    let amount: Balance = contract_env::attached_value();\n    let current_block_time: BlockTime = contract_env::get_block_time();\n\n    // Multiple lock check\n    if self.balances.get(&caller).is_some() {\n        contract_env::revert(Error::CannotLockTwice)\n    }\n\n    // Update state, emit event\n    self.balances.set(&caller, amount);\n    self.lock_expiration_map\n        .set(&caller, current_block_time + self.lock_duration());\n    Deposit {\n        address: caller,\n        amount\n    }\n    .emit();\n}\n")),(0,r.kt)("p",null,"If you try to send tokens to a non-payable function, the transaction will be automatically rejected."),(0,r.kt)("h2",{id:"non-reentrant"},"Non Reentrant"),(0,r.kt)("p",null,"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. "),(0,r.kt)("p",null,"To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. "),(0,r.kt)("p",null,"They can also use reentrancy guards to block recursive calls to sensitive functions."),(0,r.kt)("p",null,"In Odra you can just apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra(non_reentrant)]")," attribute to your function."),(0,r.kt)("h2",{id:"mixing-attributes"},"Mixing attributes"),(0,r.kt)("p",null,"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable.\nTo apply multiple attributes, you can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra(payable, non_reentrant)]\nfn deposit() {\n  // your logic...\n}\n")),(0,r.kt)("p",null,"or "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra(payable)]\n#[odra(non_reentrant)]\nfn deposit() {\n  // your logic...\n}\n")),(0,r.kt)("p",null,"In both cases attributes order does not matter."),(0,r.kt)("p",null,"However, a constructor cannot be payable, so the below code would not compile."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra(payable)]\n#[odra(init)]\nfn initialize() {\n  // your logic...\n}\n")))}d.isMDXComponent=!0}}]);