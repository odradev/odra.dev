"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"casper-zk-risc0","metadata":{"permalink":"/blog/casper-zk-risc0","source":"@site/blog/2022-12-12-casper-zk-risc0.md","title":"Zero Knowledge on Casper","description":"In this post, I present how to verify a zero knowledge proof on Casper.","date":"2022-12-12T00:00:00.000Z","formattedDate":"December 12, 2022","tags":[],"readingTime":4.215,"hasTruncateMarker":true,"authors":[{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"casper-zk-risc0","title":"Zero Knowledge on Casper","authors":["zie1ony"],"image":"https://github.com/odradev.png"},"nextItem":{"title":"Odra 0.2.0 Released","permalink":"/blog/release-020"}},"content":"In this post, I present how to verify a zero knowledge proof on Casper.\\n\x3c!--truncate--\x3e\\n\\n## Zero Knowledge\\nIn my opinion, the **zero knowledge** (ZK) is the largest revolution in \\nblockchains, since Ethereum introduced Turing-complete, account-based \\nsmart contracts.\\nTo put it in simple words, ZK enables two use cases not possible before:\\n\\n1. Computation scaling - I can perform expensive computation off-chain\\nand put the result on a chain with the proof.\\n2. Anonymity - I can prove to you, I know something without revealing it. \\n\\n## Risc Zero\\nI\'d like to introduce you to [Risc Zero](https://www.risczero.com/).\\nIt is the general purpose zero-knowledge virtual machine.\\nGo ahead and spend time reading their website!\\nFor us, the key component is the proof verifier that can be compiled into WASM.\\nSooo... we can run it on Casper :)\\nYes! We can prove any program, produce proof, and send it to Casper\'s\\nsmart contract for verification.\\n\\n## Example\\nLet\'s dive into the example to see how it works.\\n[The full example code](https://github.com/odradev/casper-zk-with-risc0)\\nyou can find on our GitHub. \\nIt is based on Risc Zero\'s [Hello, Multiply!](https://www.risczero.com/docs/examples/hello_multiply)\\nexample. So make sure you understand it first.\\n[Guest](#guest) and [Prover](#prover) sections are taken from this example.\\n\\n### Guest\\nThe program we are proving is called a **guest** in Risc Zero.\\nOur goal is to prove we know the factors of an arbitrary number.\\nGiven `a` and `b` below guest program computes `a * b` and produces\\na proof of computation.\\n\\n```rust title=\\"methods/guest/src/multiply.rs\\"\\npub fn main() {\\n    // Load the first number from the host\\n    let a: u64 = env::read();\\n    // Load the second number from the host\\n    let b: u64 = env::read();\\n    // Verify that neither of them are 1 (i.e. nontrivial factors)\\n    if a == 1 || b == 1 {\\n        panic!(\\"Trivial factors\\")\\n    }\\n    // Compute the product while being careful with integer overflow\\n    let product = a.checked_mul(b).expect(\\"Integer overflow\\");\\n    env::commit(&product);\\n}\\n```\\n\\n### Prover\\nIt\'s time to run the guest program and build the proof for \\na specific `a` and `b` values.\\n\\n```rust title=\\"prover/src/main.rs\\"\\nfn main() {\\n    // Pick two numbers.\\n    let a: u64 = 17;\\n    let b: u64 = 23;\\n\\n    // First, we make the prover, loading the \'multiply\' method.\\n    let multiply_src = std::fs::read(MULTIPLY_PATH)\\n        .expect(\\"Method code should be present at the specified path.\\");\\n    let mut prover = Prover::new(&multiply_src, MULTIPLY_ID)\\n        .expect(\\"Prover should be constructed.\\",);\\n\\n    // Next we send a & b to the guest.\\n    prover.add_input_u32_slice(to_vec(&a).unwrap().as_slice());\\n    prover.add_input_u32_slice(to_vec(&b).unwrap().as_slice());\\n    \\n    // Run prover & generate receipt\\n    let receipt = prover.run()\\n        .expect(\\"Valid code should be provable.\\");\\n\\n    // Extract journal of receipt (i.e. output c, where c = a * b)\\n    let c: u64 = from_slice(&receipt.journal)\\n        .expect(\\"Journal output should deserialize.\\");\\n\\n    // Print an assertion\\n    println!(\\"I know the factors of {}, and I can prove it!\\", c);\\n\\n    // Verify receipt, panic if it\'s wrong.\\n    receipt.verify(MULTIPLY_ID).expect(\\n        \\"Code you have proven should successfully verify.\\",\\n    );\\n\\n    // Convert journal to string and store on disk.\\n    let journal = serde_json::to_string(&receipt.journal).unwrap();\\n    write_to_file(\\"../data/journal\\", &journal);\\n\\n    // Convert seal to string and store on disk.\\n    let seal = serde_json::to_string(&receipt.seal).unwrap();\\n    write_to_file(\\"../data/seal\\", &seal);\\n\\n    // Convert method_id to string and store on disk.\\n    let result = serde_json::to_string(MULTIPLY_ID).unwrap();\\n    write_to_file(\\"../data/method\\", &result);\\n}\\n```\\n\\n### Verifier\\nNow the verification step.\\nGiven the proof (journal + seal) and the guest program definition (method),\\nCasper\'s smart contract checks its correctness. This one is written\\njust for the demonstration, but in general you want `METHOD_ID` to be\\nstored in your contract and both `SEAL` and `JOURNAL` to be passed to\\nthe contract via arguments from the outside.\\n\\n```rust title=\\"verifier/src/verifier_contract.rs\\"\\n// Import the proof and the method.\\nconst METHOD_ID: &[u8] = &include!(\\"../../data/method\\");\\nconst SEAL: &[u32] = &include!(\\"../../data/seal\\");\\nconst JOURNAL: &[u32] = &include!(\\"../../data/journal\\");\\n\\n// Verifier contract holds a result of the zk verification. \\n#[odra::module]\\npub struct Verifier {\\n    result: Variable<String>,\\n}\\n\\n#[odra::module]\\nimpl Verifier {\\n    // Calling this entry point triggers the zk proof verification.\\n    pub fn verify(&mut self) {\\n        let result = verify(JOURNAL, SEAL, METHOD_ID);\\n        self.result.set(result);\\n    }\\n\\n    // Result getter.\\n    pub fn result(&self) -> String {\\n        self.result.get().unwrap_or(String::from(\\"Not processed\\"))\\n    }\\n}\\n\\n// The verification method. It constructs new Receipt and verifies it.\\nfn verify(journal: &[u32], seal: &[u32], method_id: &[u8]) -> String {\\n    let result = Receipt::new(&journal, &seal).verify(method_id);\\n\\n    match result {\\n        Ok(()) => String::from(\\"Ok\\"),\\n        Err(err) => format!(\\"Error: {}\\", err.to_string())\\n    }\\n}\\n```\\n\\n### Livenet results\\nI have deployed it to the testnet and called the `verify` method.\\nThe `result` was `Ok`. Wow, first-ever ZK proof verification on Casper.\\nTrustless bridging, layer 2 here we come :)\\n\\nThe cost of running the `verify` method is `2324 CSPR`. That\'s a lot, but\\nwe have to start somewhere.\\n\\n## What next\\nI think it is a good place to outline possible Casper ZK goals for moving\\nthis forward. The community should discuss: \\n1. Building more examples. Risc Zero has a nice battleship game to port over\\nto Casper.\\n2. Adding Risc Zero verification method to Casper\'s FFI.\\n3. Supporting Risc Zero team. We should help develop this awesome\\nopen-source project and gain the ZK expertise.\\n\\n## Join us\\nInterested in zero knowledge on Casper?\\n\\nJoin [our Discord][odra-discord], [our Twitter][odra-twitter] or write us\\nat contact@odra.dev.\\n\\n[odra-discord]:    https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]:    https://twitter.com/odradev"},{"id":"release-020","metadata":{"permalink":"/blog/release-020","source":"@site/blog/2022-11-30-release-020/index.md","title":"Odra 0.2.0 Released","description":"We want to introduce you to the very first public release of the Odra Framework proudly!","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[],"readingTime":3.07,"hasTruncateMarker":true,"authors":[{"name":"Kuba P\u0142askonka","title":"Lead Developer","url":"https://github.com/kubaplas","key":"kubaplas"},{"name":"Krzysztof Pobiar\u017cyn","title":"Lead Developer","url":"https://github.com/kpob","key":"kpob"},{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"release-020","title":"Odra 0.2.0 Released","authors":["kubaplas","kpob","zie1ony"],"image":"https://github.com/odradev.png"},"prevItem":{"title":"Zero Knowledge on Casper","permalink":"/blog/casper-zk-risc0"}},"content":"We want to introduce you to the very first public release of the Odra Framework proudly!\\n\\n\x3c!--truncate--\x3e\\n\\n## A bit of history\\nMore than a year ago Maciej Zieli\u0144ski resigned from the position of Ecosystem Leader at [CasperLabs][casperlabs].\\nAlong with Krzysztof Pobiar\u017cyn and Kuba P\u0142askonka, we formed an engineering team dedicated to smart contracts.\\n\\nLooking at the blockchain ecosystems from the smart contract developer perspective there are two universes.\\nThe first one is Solidity, which thrives and is at its best now.\\nIt has a ton of well-tested code and security tooling.\\nWhenever an EVM-based blockchain pops out it gets populated by forks of DeFi and DAO protocols.\\nFascinating network effect emerges - code written for one EVM-based blockchain can be run on every other EVM-based blockchain.\\nThe second universe is Rust which compiles to WebAssembly.\\nHere developer communities live in the guarded cities of Polkadot, Cosmos, Solana, Casper, and Near. \\nThe code written for one platform is not portable.\\nThe network effect never had a chance to arise.\\n\\nThe main reason why Odra exists is achieving this cross-chain code reusability.\\nWe could paraphrase a bit and say:\\n\\"One to bring them all and in the code bind them.\\"\\n\\n## Odra for Casper\\nThe very first blockchain we have integrated with Odra is Casper.\\nIn comparison to [casper-contract][casper-contract] API, it greatly cuts development time and offers a much lower entry level.\\nThe Odra interface is developer friendly and people familiar with Solidity, [Ink][ink], or [Near][near-sdk] will feel like at home.\\nWe hope it will unleash the creativity and bring a whole bunch of products onto Casper.\\n\\n## Odra Framework\\n\\nOdra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design.\\nBuilt by experienced developers, it takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel.\\nIt\'s free and open source.\\n\\nOdra\'s goal is to become the go-to smart contract framework for all WebAssembly-based blockchains. \\n\\nA smart contract written using Odra can be executed on all integrated systems.\\nWe can do it by abstracting over core concepts that all the above systems are built around. \\nThese are type system, storage, entry points, execution context, and testing environment.\\nWe believe it will bring standardization to the development of Rust-based smart contracts and enable code reusability we have not yet seen in this ecosystem.\\n\\nLet\u2019s look at a Flipper contract, that holds a boolean value.\\nThe contract has a constructor that sets the initial value, and two entry points: `flip()` and `get()`, to change and query the current value, respectively.\\n\\n```rust\\nuse odra::Variable;\\n\\n#[odra::module]\\npub struct Flipper {\\n    value: Variable<bool>,\\n}\\n\\n#[odra::module]\\nimpl Flipper {\\n\\n    #[odra(init)]\\n    pub fn init(&mut self, value: bool) {\\n        self.value.set(value);\\n    }\\n\\n    pub fn flip(&mut self) {\\n        self.value.set(!self.get());\\n    }\\n\\n    pub fn get(&self) -> bool {\\n        self.value.get_or_default()\\n    }\\n}\\n```\\n\\nIt comes with the CLI tool [cargo-odra][cargo-odra] that makes it easy to use Odra.\\n\\n![cargo-odra](./cargo_odra.gif)\\n\\nNeat and simple, isn\'t it? Do you like it? Start flowing with us!\\n\\n## What next\\n\\nLet\'s be honest, we are just starting.\\nThe codebase is still hot.\\nOn the other hand, we are happy with the interfaces we designed.\\nNow is the time to write documentation and tutorials.\\nWe are also building the modules library inspired by [OpenZeppelin][open-zeppelin].\\nThe security code audit is still ahead of us.\\n\\n## Join us\\n\\nCheck out the [Odra GitHub repository][odra-repo] for more info on how to get the most out of Odra. \\nShould you have questions, join [our Discord][odra-discord], [our Twitter][odra-twitter] or write us at contact@odra.dev.\\n\\n[casperlabs]:      https://casperlabs.io\\n[odra-repo]:       https://github.com/odradev/odra\\n[cargo-odra]:      https://github.com/odradev/cargo-odra\\n[odra-discord]:    https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]:    https://twitter.com/odradev\\n[casper-contract]: https://crates.io/crates/casper-contract\\n[ink]:             https://crates.io/crates/ink_lang\\n[near-sdk]:        https://crates.io/crates/near-sdk\\n[open-zeppelin]:   https://github.com/OpenZeppelin/openzeppelin-contracts/"}]}')}}]);