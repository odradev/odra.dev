"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[99680],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=r.createContext({}),d=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=d(e.components);return r.createElement(i.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(t),m=o,h=p["".concat(i,".").concat(m)]||p[m]||u[m]||a;return t?r.createElement(h,l(l({ref:n},c),{},{components:t})):r.createElement(h,l({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,l=new Array(a);l[0]=p;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var d=2;d<a;d++)l[d]=t[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3529:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=t(87462),o=(t(67294),t(3905));const a={sidebar_position:4},l="Access Control",s={unversionedId:"tutorials/access-control",id:"version-0.7.0/tutorials/access-control",title:"Access Control",description:"In a previous tutorial, we introduced the Ownable module, which serves the purpose of securing access to specific contract features. While it establishes a fundamental security layer, there are numerous scenarios where this level of security is insufficient,",source:"@site/versioned_docs/version-0.7.0/tutorials/access-control.md",sourceDirName:"tutorials",slug:"/tutorials/access-control",permalink:"/docs/0.7.0/tutorials/access-control",draft:!1,tags:[],version:"0.7.0",lastUpdatedAt:1699367878,formattedLastUpdatedAt:"Nov 7, 2023",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"OwnedToken",permalink:"/docs/0.7.0/tutorials/owned-token"},next:{title:"Pausable",permalink:"/docs/0.7.0/tutorials/pauseable"}},i={},d=[{value:"Code",id:"code",level:2},{value:"Events and Errors",id:"events-and-errors",level:3},{value:"Module",id:"module",level:3}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"access-control"},"Access Control"),(0,o.kt)("p",null,"In a previous tutorial, we introduced the ",(0,o.kt)("a",{parentName:"p",href:"/docs/0.7.0/tutorials/ownable"},(0,o.kt)("inlineCode",{parentName:"a"},"Ownable"))," module, which serves the purpose of securing access to specific contract features. While it establishes a fundamental security layer, there are numerous scenarios where this level of security is insufficient, "),(0,o.kt)("p",null,"In this article we design and implement a more fine-grained access control layer."),(0,o.kt)("h2",{id:"code"},"Code"),(0,o.kt)("p",null,"Before we start writing code, we list the functionalities of our access control layer."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," type is used across the module."),(0,o.kt)("li",{parentName:"ol"},"A ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," can be assigned to many ",(0,o.kt)("inlineCode",{parentName:"li"},"Address"),"es."),(0,o.kt)("li",{parentName:"ol"},"Each ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," may have a corresponding admin role."),(0,o.kt)("li",{parentName:"ol"},"Only an admin can grant/revoke a ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),"."),(0,o.kt)("li",{parentName:"ol"},"A ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," can be renounced."),(0,o.kt)("li",{parentName:"ol"},"A ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," cannot be renounced on someone's behalf."),(0,o.kt)("li",{parentName:"ol"},"Each action triggers an event."),(0,o.kt)("li",{parentName:"ol"},"Unauthorized access stops contract execution.")),(0,o.kt)("h3",{id:"events-and-errors"},"Events and Errors"),(0,o.kt)("p",null,"There are three actions that can be performed concerning a ",(0,o.kt)("inlineCode",{parentName:"p"},"Role"),": granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=events.rs showLineNumbers",title:"events.rs",showLineNumbers:!0},"use odra::{types::Address, Event};\nuse super::access_control::Role;\n\n#[derive(Event, PartialEq, Eq, Debug)]\npub struct RoleGranted {\n    pub role: Role,\n    pub address: Address,\n    pub sender: Address\n}\n\n#[derive(Event, PartialEq, Eq, Debug)]\npub struct RoleRevoked {\n    pub role: Role,\n    pub address: Address,\n    pub sender: Address\n}\n\n#[derive(Event, PartialEq, Eq, Debug)]\npub struct RoleAdminChanged {\n    pub role: Role,\n    pub previous_admin_role: Role,\n    pub new_admin_role: Role\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L4-L16")," - to describe the grant or revoke actions, our events specify the ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"Address"),"es indicating who receives or loses access and who provides or withdraws it."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L18-L21")," - the event describing the admin role change, requires the subject ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),", the previous and the current admin ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=errors.rs",title:"errors.rs"},"use odra::execution_error;\n\nexecution_error! {\n    pub enum Error {\n        MissingRole => 20_000,\n        RoleRenounceForAnotherAddress => 20_001,\n    }\n}\n")),(0,o.kt)("p",null,"Errors definition is straightforward - there are only two invalid states: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"An action is triggered by an unauthorized actor."),(0,o.kt)("li",{parentName:"ol"},"The caller is attempting to resign the Role on someone's behalf.  ")),(0,o.kt)("h3",{id:"module"},"Module"),(0,o.kt)("p",null,"Now, we are stepping into the most interesting part: the module definition and implementation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=access_control.rs showLineNumbers",title:"access_control.rs",showLineNumbers:!0},"use super::{\n    errors::Error,\n    events::{RoleAdminChanged, RoleGranted, RoleRevoked}\n};\nuse odra::{\n    contract_env,\n    types::{event::OdraEvent, Address},\n    Mapping\n};\n\npub type Role = [u8; 32];\n\npub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32];\n\n#[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked])]\npub struct AccessControl {\n    roles: Mapping<Role, Mapping<Address, bool>>,\n    role_admin: Mapping<Role, Role>\n}\n\n#[odra::module]\nimpl AccessControl {\n    pub fn has_role(&self, role: &Role, address: &Address) -> bool {\n        self.roles.get_instance(role).get_or_default(address)\n    }\n\n    pub fn get_role_admin(&self, role: &Role) -> Role {\n        let admin_role = self.role_admin.get(role);\n        if let Some(admin) = admin_role {\n            admin\n        } else {\n            DEFAULT_ADMIN_ROLE\n        }\n    }\n\n    pub fn grant_role(&mut self, role: &Role, address: &Address) {\n        self.check_role(&self.get_role_admin(role), &contract_env::caller());\n        self.unchecked_grant_role(role, address);\n    }\n\n    pub fn revoke_role(&mut self, role: &Role, address: &Address) {\n        self.check_role(&self.get_role_admin(role), &contract_env::caller());\n        self.unchecked_revoke_role(role, address);\n    }\n\n    pub fn renounce_role(&mut self, role: &Role, address: &Address) {\n        if address != &contract_env::caller() {\n            contract_env::revert(Error::RoleRenounceForAnotherAddress);\n        }\n        self.unchecked_revoke_role(role, address);\n    }\n}\n\nimpl AccessControl {\n    pub fn check_role(&self, role: &Role, address: &Address) {\n        if !self.has_role(role, address) {\n            contract_env::revert(Error::MissingRole);\n        }\n    }\n\n    pub fn set_admin_role(&mut self, role: &Role, admin_role: &Role) {\n        let previous_admin_role = self.get_role_admin(role);\n        self.role_admin.set(role, *admin_role);\n        RoleAdminChanged {\n            role: *role,\n            previous_admin_role,\n            new_admin_role: *admin_role\n        }\n        .emit();\n    }\n\n    pub fn unchecked_grant_role(&mut self, role: &Role, address: &Address) {\n        if !self.has_role(role, address) {\n            self.roles.get_instance(role).set(address, true);\n            RoleGranted {\n                role: *role,\n                address: *address,\n                sender: contract_env::caller()\n            }\n            .emit();\n        }\n    }\n\n    pub fn unchecked_revoke_role(&mut self, role: &Role, address: &Address) {\n        if self.has_role(role, address) {\n            self.roles.get_instance(role).set(address, false);\n            RoleRevoked {\n                role: *role,\n                address: *address,\n                sender: contract_env::caller()\n            }\n            .emit();\n        }\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L11")," - Firstly, we need the ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," type. It is simply an alias for a 32-byte array."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L13")," - The default role is an array filled with zeros."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L15-L19")," - The storage consists of two mappings:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"roles - a nested mapping that stores information about whether a certain Role is granted to a given ",(0,o.kt)("inlineCode",{parentName:"li"},"Address"),"."),(0,o.kt)("li",{parentName:"ol"},"role_admin - each ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," can have a single admin ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),".")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L23-L25")," - This is a simple check to determine if a ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," has been granted to a given ",(0,o.kt)("inlineCode",{parentName:"li"},"Address"),". It is an exposed entry point and an important building block widely used throughout the entire module."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L54")," - This is a non-exported block containing helper functions."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L55-L59")," - The ",(0,o.kt)("inlineCode",{parentName:"li"},"check_role()")," function serves as a guard function. Before a ",(0,o.kt)("inlineCode",{parentName:"li"},"Role")," is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with ",(0,o.kt)("inlineCode",{parentName:"li"},"Error::MissingRole"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L61-L70")," - The ",(0,o.kt)("inlineCode",{parentName:"li"},"set_admin_role()")," function simply updates the role_admin mapping and emits the ",(0,o.kt)("inlineCode",{parentName:"li"},"RoleAdminChanged")," event."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L72-L94")," - The ",(0,o.kt)("inlineCode",{parentName:"li"},"unchecked_grant_role()")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"unchecked_revoke_role()")," functions are mirror functions that update the roles mapping and post ",(0,o.kt)("inlineCode",{parentName:"li"},"RoleGranted")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"RoleRevoked")," events. If the role is already granted, ",(0,o.kt)("inlineCode",{parentName:"li"},"unchecked_grant_role()")," has no effect (the opposite check is made in the case of revoking a role)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L27-L34")," - The ",(0,o.kt)("inlineCode",{parentName:"li"},"get_role_admin()")," entry point reads the role_admin. If there is no admin role for a given role, it returns the default role."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"L36-L51")," - This is a combination of ",(0,o.kt)("inlineCode",{parentName:"li"},"check_role()")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"unchecked_*_role()"),". Entry points fail on unauthorized access.")))}u.isMDXComponent=!0}}]);