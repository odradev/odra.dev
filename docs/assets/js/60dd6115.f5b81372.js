"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[73069],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,f=u["".concat(i,".").concat(m)]||u[m]||p[m]||s;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<s;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},21229:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:10,description:"Contracts calling contracts"},o="Cross calls",l={unversionedId:"basics/cross-calls",id:"version-0.5.0/basics/cross-calls",title:"Cross calls",description:"Contracts calling contracts",source:"@site/versioned_docs/version-0.5.0/basics/10-cross-calls.md",sourceDirName:"basics",slug:"/basics/cross-calls",permalink:"/docs/0.5.0/basics/cross-calls",draft:!1,tags:[],version:"0.5.0",lastUpdatedAt:1691663853,formattedLastUpdatedAt:"Aug 10, 2023",sidebarPosition:10,frontMatter:{sidebar_position:10,description:"Contracts calling contracts"},sidebar:"tutorialSidebar",previous:{title:"Events",permalink:"/docs/0.5.0/basics/events"},next:{title:"Modules",permalink:"/docs/0.5.0/basics/modules"}},i={},c=[{value:"Contract Ref",id:"contract-ref",level:2},{value:"Testing",id:"testing",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cross-calls"},"Cross calls"),(0,r.kt)("p",null,"To show how to handle calls between contracts, first, let's implement two of them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"use odra::Variable;\nuse odra::types::{Address};\n\n#[odra::module]\npub struct CrossContract {\n    pub math_engine: Variable<Address>,\n}\n\n#[odra::module]\nimpl CrossContract {\n    #[odra(init)]\n    pub fn init(&mut self, math_engine_address: Address) {\n        self.math_engine.set(math_engine_address);\n    }\n\n    pub fn add_using_another(&self) -> u32 {\n        let math_engine_address = self.math_engine.get().unwrap();\n        MathEngineRef::at(math_engine_address).add(3, 5)\n    }\n}\n\n#[odra::module]\npub struct MathEngine {\n}\n\n#[odra::module]\nimpl MathEngine {\n    pub fn add(&self, n1: u32, n2: u32) -> u32 {\n        n1 + n2\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," contract can add two numbers. ",(0,r.kt)("inlineCode",{parentName:"p"},"CrossContract")," takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," in its init function and saves it in\nstorage for later use. If we deploy the ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," first and take note of its address, we can then deploy\n",(0,r.kt)("inlineCode",{parentName:"p"},"CrossContract")," and use ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," to perform complicated calculations for us!"),(0,r.kt)("p",null,"To call the external contract, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," that was created for us by Odra:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"MathEngineRef::at(math_engine_address).add(3, 5)\n")),(0,r.kt)("h2",{id:"contract-ref"},"Contract Ref"),(0,r.kt)("p",null,"We mentioned ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," already in our ",(0,r.kt)("a",{parentName:"p",href:"/docs/0.5.0/basics/testing"},"Testing")," article.\nIt is a reference to already deployed - running contract.\nHere we are going to take a deeper look at it."),(0,r.kt)("p",null,"Similarly to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Deployer"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," is generated automatically, thanks to the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::module]")," macro.\nTo get an instance of a reference, we can either deploy a contract (using ",(0,r.kt)("inlineCode",{parentName:"p"},"Deployer"),") or by building it\ndirectly, using ",(0,r.kt)("inlineCode",{parentName:"p"},"::at(address: Address)")," method, as shown above.\nThe reference implements all the public endpoints to the contract (those marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"pub")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::module]"),"\nimpl), alongside couple methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"at(Address) -> Self")," - points the reference to an Address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"address() -> Address")," - returns the Address the reference is currently pointing at"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"with_tokens(Amount) -> Self")," - attaches Amount of native tokens to the next call")),(0,r.kt)("h1",{id:"external-contracts"},"External Contracts"),(0,r.kt)("p",null,"Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI."),(0,r.kt)("p",null,"For that purpose, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra:external_contract]")," macro. This macro should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of."),(0,r.kt)("p",null,"Let's pretend the ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," we defined is an external contract. There is a contract with ",(0,r.kt)("inlineCode",{parentName:"p"},"add()")," function that adds two numbers somewhere."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"#[odra::external_contract]\npub trait Adder {\n    fn add(&self, n1: u32, n2: u32) -> u32;\n}\n")),(0,r.kt)("p",null,"Analogously to modules, Odra creates the ",(0,r.kt)("inlineCode",{parentName:"p"},"AdderRef")," struct (but do not create the ",(0,r.kt)("inlineCode",{parentName:"p"},"AdderDeployer"),"). Having an address we can call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"AdderRef::at(address).add(3, 5)\n")),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("p",null,"Let's see how we can test our cross calls using this knowledge:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"use super::{CrossContractDeployer, MathEngineDeployer};\n\n#[test]\nfn test_cross_calls() {\n    let math_engine_contract = MathEngineDeployer::default();\n    let cross_contract = CrossContractDeployer::init(math_engine_contract.address());\n\n    assert_eq!(cross_contract.add_using_another(), 8);\n}\n")),(0,r.kt)("p",null,"Each test start with a fresh instance of blockchain - no contracts are deployed. To test an external contract we deploy a ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," contract first, but we are not going to use it directly. We take only its address. Let's keep pretending, there is a contract with the ",(0,r.kt)("inlineCode",{parentName:"p"},"add()")," function we want to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"#[cfg(test)]\nmod tests {\n    use odra::types::Address;\n    use crate::features::cross_calls::{Adder, AdderRef};\n    \n    #[test]\n    fn test_ext() {\n        let adder = AdderRef::at(get_adder_address());\n\n        assert_eq!(adder.add(1, 2), 3);\n    }\n\n    fn get_adder_address() -> Address {\n        let contract = MathEngineDeployer::default();\n        contract.address()\n    }\n}\n")))}p.isMDXComponent=!0}}]);